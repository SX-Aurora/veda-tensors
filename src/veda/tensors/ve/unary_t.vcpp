#include "kernel.h"

//------------------------------------------------------------------------------
#define UnaryT(NAME, ...)\
	template<typename S>\
	struct NAME {\
		template<typename T>\
		inline S operator()(const T a) const {\
			return __VA_ARGS__;\
		}\
	}

UnaryT(Abs,			std::abs(a));
UnaryT(Sqrt,		std::sqrt(a));
UnaryT(Rsqrt,		1/std::sqrt(a));
UnaryT(Sin,			std::sin(a));
UnaryT(Cos,			std::cos(a));
UnaryT(Tan,			std::tan(a));
UnaryT(Exp,			std::exp(a));
UnaryT(Log,			std::log(a));
UnaryT(Ceil,		std::ceil(a));
UnaryT(Floor,		std::floor(a));
UnaryT(Reciprocal,	1/a);
#undef UnaryT

//------------------------------------------------------------------------------
template<typename T>
inline VEDAresult veda_tensors_unary_t(void* o, const void* x, const size_t co, const size_t cx, const int32_t op) {
	switch(op) {
		case VEDA_TENSORS_UNARYOP_ABS:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Abs<T>());
		case VEDA_TENSORS_UNARYOP_SQRT:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Sqrt<T>());
		case VEDA_TENSORS_UNARYOP_RSQRT:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Rsqrt<T>());
		case VEDA_TENSORS_UNARYOP_SIN:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Sin<T>());
		case VEDA_TENSORS_UNARYOP_COS:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Cos<T>());
		case VEDA_TENSORS_UNARYOP_TAN:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Tan<T>());
		case VEDA_TENSORS_UNARYOP_EXP:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Exp<T>());
		case VEDA_TENSORS_UNARYOP_LOG:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Log<T>());
		case VEDA_TENSORS_UNARYOP_CEIL:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Ceil<T>());
		case VEDA_TENSORS_UNARYOP_FLOOR:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Floor<T>());
		case VEDA_TENSORS_UNARYOP_RECIPROCAL:	return veda_tensors_x((T*)o, (const T*)x, co, cx, Reciprocal<T>());
	}
	return VEDA_ERROR_NOT_IMPLEMENTED;
}

//------------------------------------------------------------------------------
template<typename S, typename T>
inline VEDAresult veda_tensors_unary_t(void* o, const void* x, const size_t co, const size_t cx, const int32_t op) {
	switch(op) {
		// TODO: case VEDA_TENSORS_UNARYOP_SQRT:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Sqrt());
		// TODO: case VEDA_TENSORS_UNARYOP_RSQRT:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Rsqrt());
		// TODO: case VEDA_TENSORS_UNARYOP_SIN:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Sin());
		// TODO: case VEDA_TENSORS_UNARYOP_COS:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Cos());
		// TODO: case VEDA_TENSORS_UNARYOP_TAN:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Tan());
		// TODO: case VEDA_TENSORS_UNARYOP_EXP:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Exp());
		// TODO: case VEDA_TENSORS_UNARYOP_LOG:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Log());
		//case VEDA_TENSORS_UNARYOP_CEIL:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Ceil());
		//case VEDA_TENSORS_UNARYOP_FLOOR:			return veda_tensors_x((T*)o, (const T*)x, co, cx, Floor());
		// TODO: case VEDA_TENSORS_UNARYOP_RECIPROCAL:	return veda_tensors_x((T*)o, (const T*)x, co, cx, Reciprocal());
	}
	return VEDA_ERROR_NOT_IMPLEMENTED;
}

//------------------------------------------------------------------------------
extern "C" void veda_tensors_unary_t(VEDAdeviceptr _o, VEDAdeviceptr _x, const size_t co, const size_t cx, const int32_t op, const int32_t type) {
	auto o	= VEDAptr<void>(_o).ptr();
	auto x	= VEDAptr<void>(_x).ptr();
	KERNEL_ALL(type, veda_tensors_unary_t, o, x, co, cx, op)
}

//------------------------------------------------------------------------------

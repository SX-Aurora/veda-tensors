#include "api.h"

//------------------------------------------------------------------------------
template<typename T>
inline void veda_tensors_masked_fill(T* out, const T value, const boolean* mask, const size_t elements) {
	veda_omp_simd(elements, veda_tensors_parallel_vlen<T>(), [&](const size_t min, const size_t max) {
		for(size_t i = min; i < max; i++)
			if(mask[i]) 
				out[i] = value;
	});
}

//------------------------------------------------------------------------------
template<typename T>
inline void veda_tensors_masked_fill(T* out, const T* values, const boolean* mask, const size_t elements) {
	veda_omp_simd(elements, veda_tensors_parallel_vlen<T>(), [&](const size_t min, const size_t max) {
		for(size_t i = min; i < max; i++)
			if(mask[i]) 
				out[i] = values[i];
	});
}

//------------------------------------------------------------------------------
extern "C" void veda_tensors_masked_fill_t(VEDAdeviceptr _out, VEDAdeviceptr _value, VEDAdeviceptr _mask, const size_t elements, const size_t otherElements, const int32_t bytes) {
	auto out	= VEDAptr<void>	(_out)		.ptr();
	auto value	= VEDAptr<void>	(_value)	.ptr();
	auto mask	= VEDAptr<boolean>(_mask)	.ptr();
	if(otherElements == 1) {
		switch(bytes) {
			case 1:	FVEDA(veda_tensors_masked_fill<int8_t> ((int8_t*) out, *(const int8_t*) value, mask, elements)); return;
			case 2:	FVEDA(veda_tensors_masked_fill<int16_t>((int16_t*)out, *(const int16_t*)value, mask, elements)); return;
			case 4:	FVEDA(veda_tensors_masked_fill<int32_t>((int32_t*)out, *(const int32_t*)value, mask, elements)); return;
			case 8:	FVEDA(veda_tensors_masked_fill<int64_t>((int64_t*)out, *(const int64_t*)value, mask, elements)); return;
		}
	} else if (otherElements == elements) {
		switch(bytes) {
			case 1:	FVEDA(veda_tensors_masked_fill<int8_t> ((int8_t*) out, (const int8_t*) value, mask, elements)); return;
			case 2:	FVEDA(veda_tensors_masked_fill<int16_t>((int16_t*)out, (const int16_t*)value, mask, elements)); return;
			case 4:	FVEDA(veda_tensors_masked_fill<int32_t>((int32_t*)out, (const int32_t*)value, mask, elements)); return;
			case 8:	FVEDA(veda_tensors_masked_fill<int64_t>((int64_t*)out, (const int64_t*)value, mask, elements)); return;
		}
	}

	FAIL();
}

//------------------------------------------------------------------------------

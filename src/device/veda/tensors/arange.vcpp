#include "internal.h"

//------------------------------------------------------------------------------
// General
//------------------------------------------------------------------------------
template<typename T>
inline void veda_tensors_arange_(T* _o, const size_t cnt, const T start, const T step) {
	veda_omp_simd(cnt, [&](const size_t min, const size_t max) {
		auto cnt	= max - min;
		auto o		= _o + min;
		auto value	= start + min * step;
		for(auto i = 0; i < cnt; i++)
			o[i] = value + i * step;
	}, veda_omp_vlen<T>());
}

//------------------------------------------------------------------------------
// Float
//------------------------------------------------------------------------------
template<typename T>
inline void veda_tensors_arange_float(void* o, const size_t cnt, const double start, const double step) {
	veda_tensors_arange_((T*)o, cnt, (T)start, (T)step);
}

//------------------------------------------------------------------------------
__global__ void veda_tensors_arange_float(VEDAdeviceptr _o, const int dtype, const size_t cnt, const double start, const double step) {
	auto o = VEDAptr<void>(_o).ptr();
	KERNEL_FLOAT(dtype, veda_tensors_arange_float, o, cnt, start, step)
}

//------------------------------------------------------------------------------
// Int
//------------------------------------------------------------------------------
template<typename T>
inline void veda_tensors_arange_int(void* o, const size_t cnt, const int64_t start, const int64_t step) {
	veda_tensors_arange_((T*)o, cnt, (T)start, (T)step);
}

//------------------------------------------------------------------------------
__global__ void veda_tensors_arange_int(VEDAdeviceptr _o, const int dtype, const size_t cnt, const int64_t start, const int64_t step) {
	auto o = VEDAptr<void>(_o).ptr();
	KERNEL_INTEGER(dtype, veda_tensors_arange_int, o, cnt, start, step)
}

//------------------------------------------------------------------------------

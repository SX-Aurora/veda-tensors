#include "internal.h"

//------------------------------------------------------------------------------
#define UnaryTTS(NAME, ...)\
	struct NAME {\
		template<typename S, typename T>\
		inline T operator()(const T a, const T b, const S alpha) const {\
			return __VA_ARGS__;\
		}\
	}

UnaryTTS(AlphaAdd, a + (b * alpha));
UnaryTTS(AlphaSub, a - (b * alpha));
#undef UnaryTTS

//------------------------------------------------------------------------------
template<typename S, typename T=S>
inline void veda_tensors_unary_tts(void* o, const void* x, const void* y, const void* alpha, const size_t co, const size_t cx, const size_t cy, const int op) {
	switch(op) {
		case VEDA_TENSORS_UNARY_ADD:	veda_tensors_xyz((T*)o, (const T*)x, (const T*)y, (const S*)alpha, co, cx, cy, 1, AlphaAdd());	return;
		case VEDA_TENSORS_UNARY_SUB:	veda_tensors_xyz((T*)o, (const T*)x, (const T*)y, (const S*)alpha, co, cx, cy, 1, AlphaSub());	return;
	}
	FAIL();
}

//------------------------------------------------------------------------------
__global__ void veda_tensors_unary_tts(VEDAdeviceptr _o, VEDAdeviceptr _x, VEDAdeviceptr _y, const uint64_t alpha_x, const uint64_t alpha_y, const size_t co, const size_t cx, const size_t cy, const int op, const int type) {
	auto o	= VEDAptr<void>(_o).ptr();
	auto x	= VEDAptr<void>(_x).ptr();
	auto y	= VEDAptr<void>(_y).ptr();
	const uint64_t alpha[] = {alpha_x, alpha_y};
	KERNEL_ALL(type, veda_tensors_unary_tts, o, x, y, &alpha, co, cx, cy, op);
}

//------------------------------------------------------------------------------
